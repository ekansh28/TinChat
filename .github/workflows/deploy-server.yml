name: ğŸš€ Deploy Server to VPS

on:
  push:
    branches:
      - main
    paths:
      - 'server/**'
      - '.github/workflows/deploy-server.yml'
  workflow_dispatch:  # Allows manual triggering

jobs:
  deploy:
    name: ğŸ” Deploy Server on VPS
    runs-on: ubuntu-latest

    steps:
      - name: â¬‡ï¸ Checkout Repository
        uses: actions/checkout@v3

      - name: ğŸ” Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_DEPLOY_KEY }}

      - name: ğŸ§  Add VPS Host to Known Hosts
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
        run: |
          echo "ğŸ” Adding VPS host to known hosts..."
          echo "  - VPS_HOST length: ${#VPS_HOST}"
          
          if [[ -z "$VPS_HOST" ]]; then
            echo "âŒ VPS_HOST is empty!"
            exit 1
          fi
          
          echo "ğŸ” Testing connectivity to $VPS_HOST..."
          if timeout 10 ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts; then
            echo "âœ… Successfully added $VPS_HOST to known hosts"
          else
            echo "âš ï¸ ssh-keyscan failed, trying alternative ports..."
            
            # Try common SSH ports
            for port in 22 2222 2200; do
              echo "ğŸ” Trying port $port..."
              if timeout 10 ssh-keyscan -p $port -H "$VPS_HOST" >> ~/.ssh/known_hosts 2>/dev/null; then
                echo "âœ… Successfully connected on port $port"
                break
              else
                echo "âŒ Port $port failed"
              fi
            done
            
            # If all fails, continue anyway (some servers block ssh-keyscan)
            echo "âš ï¸ ssh-keyscan failed on all ports, continuing anyway..."
            echo "This might be normal if the server blocks ssh-keyscan"
          fi

      - name: ğŸ” Verify Environment Variables
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PROJECT_PATH: ${{ secrets.VPS_PROJECT_PATH }}
          NEXT_PUBLIC_SOCKET_SERVER_URL: ${{ secrets.NEXT_PUBLIC_SOCKET_SERVER_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}
        run: |
          echo "ğŸ” Checking environment variables for server deployment:"
          echo "  - VPS_HOST length: ${#VPS_HOST}"
          echo "  - VPS_PROJECT_PATH length: ${#VPS_PROJECT_PATH}"
          echo "  - NEXT_PUBLIC_SOCKET_SERVER_URL length: ${#NEXT_PUBLIC_SOCKET_SERVER_URL}"
          echo "  - NEXT_PUBLIC_SUPABASE_URL length: ${#NEXT_PUBLIC_SUPABASE_URL}"
          echo "  - NEXT_PUBLIC_SUPABASE_ANON_KEY length: ${#NEXT_PUBLIC_SUPABASE_ANON_KEY}"
          echo "  - SUPABASE_SERVICE_ROLE_KEY length: ${#SUPABASE_SERVICE_ROLE_KEY}"
          echo "  - NEXT_PUBLIC_API_BASE_URL length: ${#NEXT_PUBLIC_API_BASE_URL}"
          echo "  - UPSTASH_REDIS_REST_URL length: ${#UPSTASH_REDIS_REST_URL}"
          echo "  - UPSTASH_REDIS_REST_TOKEN length: ${#UPSTASH_REDIS_REST_TOKEN}"
          
          if [[ -z "$VPS_HOST" ]]; then
            echo "âŒ VPS_HOST is empty!"
            exit 1
          fi
          
          if [[ -z "$VPS_PROJECT_PATH" ]]; then
            echo "âŒ VPS_PROJECT_PATH is empty!"
            exit 1
          fi
          
          if [[ -z "$NEXT_PUBLIC_SOCKET_SERVER_URL" ]]; then
            echo "âŒ NEXT_PUBLIC_SOCKET_SERVER_URL is empty!"
            exit 1
          fi
          
          echo "âœ… Required environment variables are present"

      - name: ğŸ”— Test VPS Connectivity
        env:
          VPS_USER: root
          VPS_HOST: ${{ secrets.VPS_HOST }}
        run: |
          echo "ğŸ” Testing SSH connectivity to VPS..."
          
          if timeout 30 ssh -o BatchMode=yes -o ConnectTimeout=10 $VPS_USER@$VPS_HOST 'echo "âœ… SSH connection successful"'; then
            echo "âœ… VPS is reachable and SSH key works"
          else
            echo "âŒ Failed to connect to VPS"
            echo "ğŸ” Debugging info:"
            echo "  - VPS_HOST: $VPS_HOST"
            echo "  - VPS_USER: $VPS_USER"
            echo "ğŸ” Trying to ping the host..."
            ping -c 3 $VPS_HOST || echo "âŒ Host is not reachable via ping"
            
            echo "âš ï¸ VPS connectivity test failed, but continuing anyway..."
            echo "âš ï¸ The main deployment will likely fail if VPS is unreachable"
            echo "âš ï¸ Please check your VPS status and network configuration"
          fi

      - name: ğŸš€ Deploy Server on VPS
        env:
          VPS_USER: root
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PROJECT_PATH: ${{ secrets.VPS_PROJECT_PATH }}
          NEXT_PUBLIC_SOCKET_SERVER_URL: ${{ secrets.NEXT_PUBLIC_SOCKET_SERVER_URL }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}
        run: |
          echo "ğŸ” Starting server deployment process..."
          echo "ğŸ“‹ Environment variables check:"
          echo "  - VPS_HOST: $VPS_HOST"
          echo "  - VPS_PROJECT_PATH: $VPS_PROJECT_PATH"
          echo "  - NEXT_PUBLIC_API_BASE_URL: $NEXT_PUBLIC_API_BASE_URL"
          echo "  - SOCKET_SERVER_URL length: ${#NEXT_PUBLIC_SOCKET_SERVER_URL}"
          echo "  - SUPABASE_URL length: ${#NEXT_PUBLIC_SUPABASE_URL}"
          echo "  - SUPABASE_ANON_KEY length: ${#NEXT_PUBLIC_SUPABASE_ANON_KEY}"
          echo "  - UPSTASH_REDIS_REST_URL length: ${#UPSTASH_REDIS_REST_URL}"
          echo "  - UPSTASH_REDIS_REST_TOKEN length: ${#UPSTASH_REDIS_REST_TOKEN}"
          
          # Trim whitespace and newlines from path (safety check)
          CLEAN_PATH=$(echo "$VPS_PROJECT_PATH" | tr -d '\n' | sed 's/ *$//')
          echo "  - CLEAN_PATH: $CLEAN_PATH"
          
          # Pass environment variables to SSH session for server deployment
          ssh $VPS_USER@$VPS_HOST "
            export NEXT_PUBLIC_SUPABASE_URL='$NEXT_PUBLIC_SUPABASE_URL'
            export NEXT_PUBLIC_SOCKET_SERVER_URL='$NEXT_PUBLIC_SOCKET_SERVER_URL'
            export NEXT_PUBLIC_SUPABASE_ANON_KEY='$NEXT_PUBLIC_SUPABASE_ANON_KEY'
            export SUPABASE_SERVICE_ROLE_KEY='$SUPABASE_SERVICE_ROLE_KEY'
            export NEXT_PUBLIC_API_BASE_URL='$NEXT_PUBLIC_API_BASE_URL'
            export UPSTASH_REDIS_REST_URL='$UPSTASH_REDIS_REST_URL'
            export UPSTASH_REDIS_REST_TOKEN='$UPSTASH_REDIS_REST_TOKEN'
            
            set -e
            
            echo 'ğŸ“‚ Changing to project root directory...'
            cd '$CLEAN_PATH' || { echo 'âŒ Project directory missing'; exit 1; }
            echo 'âœ… Project root directory: '\$(pwd)
            
            echo 'ğŸ”„ Force updating repository...'
            git fetch --all
            git reset --hard origin/main
            git clean -fd
            echo 'âœ… Repository updated successfully'
            
            echo 'ğŸ“‚ Changing to server directory...'
            cd server || { echo 'âŒ Server directory missing'; exit 1; }
            echo 'âœ… Current server directory: '\$(pwd)
            
            echo 'ğŸ”§ Creating server .env.local file...'
            
            # Debug: Show what variables we have (safely)
            echo 'ğŸ” Environment variables available in SSH session:'
            echo \"  NEXT_PUBLIC_SUPABASE_URL length: \${#NEXT_PUBLIC_SUPABASE_URL}\"
            echo \"  NEXT_PUBLIC_SUPABASE_ANON_KEY length: \${#NEXT_PUBLIC_SUPABASE_ANON_KEY}\"
            echo \"  SUPABASE_SERVICE_ROLE_KEY length: \${#SUPABASE_SERVICE_ROLE_KEY}\"
            echo \"  NEXT_PUBLIC_API_BASE_URL length: \${#NEXT_PUBLIC_API_BASE_URL}\"
            echo \"  NEXT_PUBLIC_SOCKET_SERVER_URL length: \${#NEXT_PUBLIC_SOCKET_SERVER_URL}\"
            echo \"  UPSTASH_REDIS_REST_URL length: \${#UPSTASH_REDIS_REST_URL}\"
            echo \"  UPSTASH_REDIS_REST_TOKEN length: \${#UPSTASH_REDIS_REST_TOKEN}\"
            
            # Create .env.local file for server with environment variables
            echo 'ğŸ”§ Creating .env.local with echo statements...'
            echo \"NEXT_PUBLIC_SUPABASE_URL=\$NEXT_PUBLIC_SUPABASE_URL\" > .env.local
            echo \"NEXT_PUBLIC_SUPABASE_ANON_KEY=\$NEXT_PUBLIC_SUPABASE_ANON_KEY\" >> .env.local
            echo \"SUPABASE_SERVICE_ROLE_KEY=\$SUPABASE_SERVICE_ROLE_KEY\" >> .env.local
            echo \"NEXT_PUBLIC_API_BASE_URL=\$NEXT_PUBLIC_API_BASE_URL\" >> .env.local
            echo \"NEXT_PUBLIC_SOCKET_SERVER_URL=\$NEXT_PUBLIC_SOCKET_SERVER_URL\" >> .env.local
            echo \"UPSTASH_REDIS_REST_URL=\$UPSTASH_REDIS_REST_URL\" >> .env.local
            echo \"UPSTASH_REDIS_REST_TOKEN=\$UPSTASH_REDIS_REST_TOKEN\" >> .env.local
            echo \"NODE_ENV=production\" >> .env.local
            
            echo 'âœ… Server environment file created'
            echo 'ğŸ” Environment file contents (redacted):'
            sed 's/=.*/=***REDACTED***/g' .env.local
            
            echo 'ğŸ” Checking server directory contents...'
            echo 'âœ… Server directory found'
            ls -la .
            
            echo 'ğŸ“¦ Installing server dependencies...'
            
            # Check if server has its own package.json (we're already in /server directory)
            if [ -f \"package.json\" ]; then
              echo 'ğŸ“¦ Installing server-specific dependencies...'
              
              # Clean install for server
              rm -rf node_modules package-lock.json
              npm cache clean --force 2>/dev/null || true
              
              npm install --no-audit --no-fund || {
                echo 'âŒ Server npm install failed, trying alternatives...'
                npm install --legacy-peer-deps --no-audit --no-fund || {
                  echo 'âŒ Server dependency installation failed'
                  echo 'ğŸ” Node and npm versions:'
                  node --version
                  npm --version
                  echo 'ğŸ” Server package.json:'
                  cat package.json | head -20
                  exit 1
                }
              }
              
              echo 'âœ… Server dependencies installed'
            else
              echo 'âŒ No package.json found in server directory!'
              echo 'ğŸ” Available files:'
              ls -la
              exit 1
            fi
            
            echo 'ğŸ” Checking for TypeScript compilation...'
            if [ -f \"tsconfig.json\" ] || grep -q '\"tsx\"' package.json 2>/dev/null; then
              echo 'ğŸ”§ TypeScript detected, checking if compilation is needed...'
              if [ -f \"dist\" ] || npm run --silent build >/dev/null 2>&1; then
                echo 'âœ… TypeScript compilation successful or not needed'
              else
                echo 'âš ï¸ TypeScript compilation skipped or failed, continuing...'
              fi
            else
              echo 'âœ… No TypeScript compilation needed'
            fi
            
            echo 'ğŸ” Checking current PM2 status...'
            pm2 list || echo 'PM2 not initialized yet'
            
            echo 'ğŸš€ Managing server PM2 process...'
            
            # Check if there's a start script in server package.json
            if grep -q '\"start\"' package.json 2>/dev/null; then
              echo 'ğŸ” Found start script in server package.json'
              
              # Kill existing server process if running
              if pm2 describe tinchat-server > /dev/null 2>&1; then
                echo 'ğŸ”„ Stopping existing server process...'
                pm2 delete tinchat-server || echo 'Failed to delete existing process'
              fi
              
              # Start new server process
              echo 'ğŸ†• Starting new server process with npm start...'
              pm2 start \"npm start\" --name \"tinchat-server\" || {
                echo 'âŒ Failed to start server with npm start'
                echo 'ğŸ” Trying alternative approaches...'
                
                # Try starting directly if npm script fails
                if [ -f \"index.js\" ]; then
                  pm2 start index.js --name 'tinchat-server'
                elif [ -f \"index.ts\" ]; then
                  pm2 start index.ts --name 'tinchat-server' --interpreter tsx
                elif [ -f \"src/index.js\" ]; then
                  pm2 start src/index.js --name 'tinchat-server'
                elif [ -f \"src/index.ts\" ]; then
                  pm2 start src/index.ts --name 'tinchat-server' --interpreter tsx
                else
                  echo 'âŒ No server entry point found'
                  echo 'ğŸ” Available files:'
                  ls -la
                  exit 1
                fi
              }
              
            elif [ -f \"index.js\" ] || [ -f \"index.ts\" ] || [ -f \"src/index.js\" ] || [ -f \"src/index.ts\" ]; then
              echo 'ğŸ” Found server entry point'
              
              if pm2 describe tinchat-server > /dev/null 2>&1; then
                echo 'ğŸ”„ Restarting existing PM2 server process...'
                pm2 restart tinchat-server
              else
                echo 'ğŸ†• Starting new PM2 server process...'
                if [ -f \"index.ts\" ]; then
                  pm2 start index.ts --name 'tinchat-server' --interpreter tsx
                elif [ -f \"src/index.ts\" ]; then
                  pm2 start src/index.ts --name 'tinchat-server' --interpreter tsx
                elif [ -f \"index.js\" ]; then
                  pm2 start index.js --name 'tinchat-server'
                elif [ -f \"src/index.js\" ]; then
                  pm2 start src/index.js --name 'tinchat-server'
                fi
              fi
            else
              echo 'âŒ No server entry point found!'
              echo 'ğŸ” Server directory contents:'
              ls -la
              echo 'ğŸ” src directory contents (if exists):'
              ls -la src/ 2>/dev/null || echo 'No src directory'
              exit 1
            fi
            
            echo 'ğŸ’¾ Saving PM2 configuration...'
            pm2 save
            
            echo 'ğŸ” Final PM2 status:'
            pm2 list
            
            echo 'ğŸ” Checking PM2 server logs (last 10 lines):'
            pm2 logs tinchat-server --lines 10 --nostream || echo 'No server logs available yet'
            
            echo 'ğŸ” Testing server response...'
            sleep 5  # Give the server time to start
            
            # Test common server ports
            for port in 3001 8080 8000 5000 4000; do
              if curl -f -s http://localhost:\$port > /dev/null; then
                echo 'âœ… Server is responding on port '\$port
                break
              else
                echo 'âš ï¸ No response on port '\$port
              fi
            done
            
            echo 'ğŸ” Network status (server ports):'
            netstat -tlnp | grep -E ':(3001|8080|8000|5000|4000)' || echo 'No server services found on common ports'
            
            echo 'ğŸ” PM2 server process memory/CPU usage:'
            pm2 show tinchat-server || echo 'Cannot show server PM2 details'
            
            echo 'âœ… Server deployment completed successfully!'
          "